# -*- coding: utf-8 -*-
"""confusion_matrix.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1gcsNUKX_g8ESyteKKsPcJio7j04it5QM
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from scipy.special import softmax
from sklearn.metrics import confusion_matrix
import ast
import os

#

# inputs
import joblib
import argparse

# Parse command-line arguments for file paths
parser = argparse.ArgumentParser(description="Generate side-by-side bar plots for actual vs predicted labels.")
parser.add_argument("--preds_path", type=str, required=True, help="Path to the saved PredictionOutput (pickle file).")
#parser.add_argument("--tokenized_path", type=str, required=True, help="Path to the saved tokenized dataset (pickle file).")
args = parser.parse_args()

# Load objects
preds_inp = joblib.load(args.preds_path)
#tokenized_datasets_inp = joblib.load(args.tokenized_path)

# Create an EDA folder if it doesn't exist
def create_eda_folder():
    current_dir = os.getcwd()

    eda_folder_path = os.path.join(current_dir, 'EDA')
    if not os.path.exists(eda_folder_path):
        os.makedirs(eda_folder_path)

def data_prep(preds):

    # probs and class assignments

    y_true = preds_inp.label_ids
    y_pred = np.argmax(preds.predictions, axis=-1)

    nb_classes = len(set(y_true))

    return y_true, y_pred, nb_classes

def all_counts():
  print("-------------------")
  print("Number of 'true' values in each class:")
  for i in range(nb_classes):
      print(i, confusion_matrix(y_true, y_pred)[i].sum())
  print("-------------------")


def cm_plot(y_true, y_pred):

  # Create counts and normalized confusion matrix
  cm = confusion_matrix(y_true, y_pred)
  cm_normalized = confusion_matrix(y_true, y_pred, normalize='true')

  # Create counts and normalized confusion matrix for best case scenario
  cm_best = confusion_matrix(y_true, y_true)
  cm_normalized_best = confusion_matrix(y_true, y_true, normalize='true')

  # Create DataFrames for better labeling
  df_cm = pd.DataFrame(cm, range(cm.shape[0]), range(cm.shape[1]))
  df_cm_norm = pd.DataFrame(cm_normalized, range(cm.shape[0]), range(cm.shape[1]))
  df_cm_best = pd.DataFrame(cm_best, range(cm.shape[0]), range(cm.shape[1]))
  df_cm_norm_best = pd.DataFrame(cm_normalized_best, range(cm.shape[0]), range(cm.shape[1]))

  # Create side-by-side subplots
  fig, axs = plt.subplots(nrows=2, ncols=2, figsize=(14, 6))
  sns.set(font_scale=1.2)

  # Plot 1: Raw confusion matrix
  sns.heatmap(df_cm, annot=True, fmt='d', cmap='Reds', ax=axs[0][0])
  axs[0][0].set_title("Confusion Matrix (Counts)")
  axs[0][0].set_xlabel("Predicted Label")
  axs[0][0].set_ylabel("True Label")

  # Plot 2: Normalized confusion matrix
  sns.heatmap(df_cm_norm, annot=True, fmt='.2f', cmap='Blues', ax=axs[0][1])
  axs[0][1].set_title("Confusion Matrix (Normalized)")
  axs[0][1].set_xlabel("Predicted Label")
  axs[0][1].set_ylabel("True Label")

  # Plot 3: Raw confusion matrix best case scenario
  sns.heatmap(df_cm_best, annot=True, fmt='d', cmap='Reds', ax=axs[1][0])
  axs[1][0].set_title("Confusion Matrix (Counts) in Best Case Scenario")
  axs[1][0].set_xlabel("Predicted Label")
  axs[1][0].set_ylabel("True Label")

  # Plot 4: Normalized confusion matrix in Best Case Scenario
  sns.heatmap(df_cm_norm_best, annot=True, fmt='.2f', cmap='Blues', ax=axs[1][1])
  axs[1][1].set_title("Confusion Matrix (Normalized)")
  axs[1][1].set_xlabel("Predicted Label")
  axs[1][1].set_ylabel("True Label")

  # Adjust layout
  plt.tight_layout()

create_eda_folder()
y_true, y_pred, nb_classes = data_prep(preds=preds_inp)
plot_to_save = cm_plot(y_true=y_true, y_pred=y_pred)
all_counts()
file_name = 'CONFUSION_MATRIX_best.png'
eda_folder_path = os.path.join(os.getcwd(), 'EDA')

all_counts()
#plt.show()

file_path = os.path.join(eda_folder_path, file_name)
#with open(file_path, 'w', encoding = 'utf-8-sig') as f:
plt.savefig(file_path)

plt.show()
text_to_display = 'File name '+file_name[:-4] +'. '+'This is also saved in the EDA folder'
print(text_to_display)
